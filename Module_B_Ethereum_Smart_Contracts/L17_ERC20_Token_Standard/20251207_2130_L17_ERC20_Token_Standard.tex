\documentclass[8pt,aspectratio=169]{beamer}
\usetheme{Madrid}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
\lstset{basicstyle=\tiny\ttfamily,breaklines=true}

\title{L17: ERC-20 Token Standard}
\subtitle{Module B: Ethereum \& Smart Contracts}
\author{Blockchain \& Cryptocurrency Course}
\date{December 2025}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Learning Objectives}
By the end of this lesson, you will be able to:
\begin{itemize}
\item Explain the purpose and importance of the ERC-20 standard
\item Describe the six required ERC-20 interface functions
\item Understand the allowance mechanism for delegated transfers
\item Implement a basic ERC-20 token from scratch
\item Use OpenZeppelin's audited ERC-20 implementation
\item Analyze real-world ERC-20 tokens (USDC, DAI, LINK)
\end{itemize}
\end{frame}

\begin{frame}{What is ERC-20?}
\textbf{ERC-20 is the dominant fungible token standard on Ethereum:}

\vspace{0.3cm}
\begin{itemize}
\item \textbf{ERC:} Ethereum Request for Comments (proposal process)
\item \textbf{20:} Proposal number (introduced November 2015 by Fabian Vogelsteller)
\item \textbf{Fungible:} Each token is identical and interchangeable (like currency)
\item \textbf{Standard:} Common interface enables interoperability
\end{itemize}

\vspace{0.3cm}
\textbf{Why Standardization Matters:}
\begin{itemize}
\item Wallets (MetaMask, Ledger) support all ERC-20 tokens without custom code
\item Exchanges can list new tokens easily
\item Smart contracts can interact with any ERC-20 token
\item Developers use common patterns and libraries
\item Reduces fragmentation and security risks
\end{itemize}

\vspace{0.3cm}
\textbf{Usage:} Currencies, governance tokens, stablecoins, utility tokens, rewards
\end{frame}

\begin{frame}[fragile]{ERC-20 Interface: Required Functions}
\textbf{Six mandatory functions:}

\begin{lstlisting}
interface IERC20 {
    // Returns the total token supply
    function totalSupply() external view returns (uint256);

    // Returns the balance of an account
    function balanceOf(address account) external view returns (uint256);

    // Transfers tokens from caller to recipient
    function transfer(address recipient, uint256 amount) external returns (bool);

    // Returns remaining tokens that spender is allowed to spend on behalf of owner
    function allowance(address owner, address spender) external view returns (uint256);

    // Sets amount as allowance of spender over caller's tokens
    function approve(address spender, uint256 amount) external returns (bool);

    // Transfers tokens from sender to recipient using allowance mechanism
    function transferFrom(address sender, address recipient, uint256 amount)
        external returns (bool);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{ERC-20 Interface: Required Events}
\textbf{Two mandatory events:}

\begin{lstlisting}
interface IERC20 {
    // Emitted when tokens are transferred
    event Transfer(address indexed from, address indexed to, uint256 value);

    // Emitted when allowance is set via approve()
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
\end{lstlisting}

\vspace{0.3cm}
\textbf{Why Events Are Required:}
\begin{itemize}
\item Enable off-chain indexing of token transfers
\item Wallets and explorers listen to Transfer events to update balances
\item DEXs track Approval events for trading activity
\item Much cheaper than storing transfer history in storage
\item Indexed parameters allow efficient filtering (e.g., all transfers to address X)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Optional Metadata Functions}
\textbf{Not required but widely used:}

\begin{lstlisting}
// Returns the name of the token (e.g., "US Dollar Coin")
function name() public view returns (string memory);

// Returns the symbol of the token (e.g., "USDC")
function symbol() public view returns (string memory);

// Returns the number of decimals (e.g., 18 for ETH-like, 6 for USDC)
function decimals() public view returns (uint8);
\end{lstlisting}

\vspace{0.3cm}
\textbf{Decimals Explained:}
\begin{itemize}
\item Tokens are stored as integers (no floating point on EVM)
\item \texttt{decimals} defines how to display token amounts
\item Example: 1 USDC = 1,000,000 units (6 decimals)
\item Example: 1 DAI = 1,000,000,000,000,000,000 units (18 decimals)
\item Convention: 18 decimals (same as ETH) unless special reason
\end{itemize}
\end{frame}

\begin{frame}{Understanding Allowance Mechanism}
\textbf{Problem:} How can a smart contract spend your tokens?

\vspace{0.3cm}
\textbf{Solution:} Two-step approve + transferFrom pattern

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{User calls approve():}
\begin{itemize}
\item \texttt{token.approve(spenderAddress, amount)}
\item Sets allowance: ``spenderAddress can spend up to amount of my tokens''
\item Emits \texttt{Approval} event
\end{itemize}

\item \textbf{Spender calls transferFrom():}
\begin{itemize}
\item \texttt{token.transferFrom(userAddress, recipient, amount)}
\item Transfers tokens from user to recipient
\item Decreases allowance by amount
\item Emits \texttt{Transfer} event
\end{itemize}
\end{enumerate}

\vspace{0.3cm}
\textbf{Use Cases:}
\begin{itemize}
\item DEX trading: User approves DEX contract to spend tokens
\item Staking: User approves staking contract to lock tokens
\item Subscription: User approves service to charge tokens periodically
\end{itemize}
\end{frame}

\begin{frame}{Allowance Example: DEX Trading}
\textbf{Scenario:} Alice wants to trade 100 DAI for ETH on Uniswap

\vspace{0.3cm}
\textbf{Step-by-Step:}
\begin{enumerate}
\item Alice calls \texttt{DAI.approve(UniswapRouter, 100e18)}
\begin{itemize}
\item Sets allowance: Uniswap can spend 100 DAI
\item Gas cost: approximately 45,000
\end{itemize}

\item Alice calls \texttt{UniswapRouter.swapTokensForETH(100e18, ...)}
\begin{itemize}
\item Uniswap calls \texttt{DAI.transferFrom(Alice, UniswapPool, 100e18)}
\item DAI transferred from Alice to Uniswap pool
\item Alice's allowance decreases to 0
\item Alice receives ETH in return
\end{itemize}

\item If Alice wants to trade again, she needs to approve again
\end{enumerate}

\vspace{0.3cm}
\textbf{Infinite Approval:}
\begin{itemize}
\item Users often approve \texttt{type(uint256).max} to avoid repeated approvals
\item Risk: If DEX contract is hacked, all approved tokens can be stolen
\item Tradeoff: Convenience vs security
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Basic ERC-20 Implementation (Part 1)}
\begin{lstlisting}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BasicERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory _name, string memory _symbol, uint8 _decimals,
                uint256 _initialSupply) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _initialSupply * 10**_decimals;
        balanceOf[msg.sender] = totalSupply;  // Mint all tokens to deployer
        emit Transfer(address(0), msg.sender, totalSupply);
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Basic ERC-20 Implementation (Part 2)}
\begin{lstlisting}
    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(recipient != address(0), "Transfer to zero address");
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");

        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        require(spender != address(0), "Approve to zero address");

        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Basic ERC-20 Implementation (Part 3)}
\begin{lstlisting}
    function transferFrom(address sender, address recipient, uint256 amount)
        public returns (bool) {
        require(sender != address(0), "Transfer from zero address");
        require(recipient != address(0), "Transfer to zero address");
        require(balanceOf[sender] >= amount, "Insufficient balance");
        require(allowance[sender][msg.sender] >= amount, "Insufficient allowance");

        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        allowance[sender][msg.sender] -= amount;

        emit Transfer(sender, recipient, amount);
        return true;
    }
}
\end{lstlisting}

\vspace{0.3cm}
\textbf{Note:} This is a minimal implementation. Production tokens should use OpenZeppelin.
\end{frame}

\begin{frame}{Security Considerations}
\textbf{Common ERC-20 Vulnerabilities:}

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{Approve Race Condition:}
\begin{itemize}
\item Problem: Changing allowance from A to B allows spender to spend A+B
\item Attack: Spender front-runs second approve() to spend both amounts
\item Solution: Use \texttt{increaseAllowance()} and \texttt{decreaseAllowance()}
\end{itemize}

\item \textbf{Integer Overflow (pre-0.8.0):}
\begin{itemize}
\item Problem: \texttt{balanceOf[user] + amount} could overflow
\item Solution: Use Solidity 0.8+ (built-in overflow checks) or SafeMath library
\end{itemize}

\item \textbf{Reentrancy in Transfer Hooks:}
\begin{itemize}
\item Problem: If token calls external contract during transfer, reentrancy possible
\item Solution: Follow checks-effects-interactions pattern
\end{itemize}

\item \textbf{Fee-on-Transfer Tokens:}
\begin{itemize}
\item Some tokens deduct fees on transfer (e.g., SAFEMOON)
\item Breaks assumption that \texttt{transfer(amount)} sends exactly \texttt{amount}
\item DEXs must check balance before/after to handle correctly
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{OpenZeppelin ERC-20 Implementation}
\textbf{Industry-standard audited implementation:}

\begin{lstlisting}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(uint256 initialSupply) ERC20("My Token", "MTK") {
        _mint(msg.sender, initialSupply * 10**decimals());
    }
}
\end{lstlisting}

\vspace{0.3cm}
\textbf{Advantages:}
\begin{itemize}
\item Battle-tested code (used by USDC, LINK, thousands of projects)
\item Security audits by leading firms
\item Gas-optimized
\item Extensions available: ERC20Burnable, ERC20Pausable, ERC20Permit
\item Regular updates for new security best practices
\end{itemize}
\end{frame}

\begin{frame}[fragile]{OpenZeppelin Extensions}
\textbf{Useful ERC-20 extensions:}

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{ERC20Burnable:}
\begin{lstlisting}
function burn(uint256 amount) public {
    _burn(msg.sender, amount);  // Destroy tokens, decrease totalSupply
}
\end{lstlisting}

\item \textbf{ERC20Pausable:}
\begin{lstlisting}
function pause() public onlyOwner {
    _pause();  // Disable all transfers
}
\end{lstlisting}

\item \textbf{ERC20Permit (EIP-2612):}
\begin{lstlisting}
function permit(address owner, address spender, uint256 value, uint256 deadline,
                uint8 v, bytes32 r, bytes32 s) public {
    // Approve via signature, no separate transaction needed
}
\end{lstlisting}
\end{enumerate}
\end{frame}

\begin{frame}{Real-World Example: USDC}
\textbf{USD Coin (USDC) - Circle's stablecoin:}

\vspace{0.3cm}
\textbf{Key Features:}
\begin{itemize}
\item Pegged 1:1 to US Dollar
\item Backed by cash and short-term US Treasuries
\item 6 decimals (not 18, to match fiat cents)
\item Upgradable proxy pattern
\item Blacklist function (regulatory compliance)
\item Pausable (emergency circuit breaker)
\end{itemize}

\vspace{0.3cm}
\textbf{Contract Structure:}
\begin{itemize}
\item \textbf{Proxy:} 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 (fixed address)
\item \textbf{Implementation:} Upgradable, currently v2.2
\item \textbf{Master Minter:} Can add/remove minters
\item \textbf{Minters:} Authorized addresses that can mint USDC
\item \textbf{Blacklister:} Can freeze addresses (e.g., sanctioned entities)
\end{itemize}
\end{frame}

\begin{frame}{Real-World Example: DAI}
\textbf{DAI - MakerDAO's decentralized stablecoin:}

\vspace{0.3cm}
\textbf{Key Features:}
\begin{itemize}
\item Pegged to 1 USD via collateralized debt positions (CDPs)
\item Over-collateralized by crypto assets (ETH, wBTC, USDC)
\item 18 decimals (standard)
\item Permissionless minting via Maker Vaults
\item No admin blacklist or pause (more decentralized than USDC)
\end{itemize}

\vspace{0.3cm}
\textbf{ERC-20 Extensions:}
\begin{itemize}
\item \texttt{permit()} - EIP-2612 gasless approvals
\item \texttt{mint()} - Only callable by Maker Vat (core contract)
\item \texttt{burn()} - Destroy DAI when repaying debt
\end{itemize}

\vspace{0.3cm}
\textbf{Address:} 0x6B175474E89094C44Da98b954EedeAC495271d0F
\end{frame}

\begin{frame}[fragile]{Real-World Example: Chainlink (LINK)}
\textbf{LINK - Chainlink's utility token:}

\vspace{0.3cm}
\textbf{Key Features:}
\begin{itemize}
\item Used to pay node operators for oracle services
\item Fixed supply: 1 billion LINK (no minting)
\item Standard ERC-20 with \texttt{transferAndCall()} extension
\item 18 decimals
\end{itemize}

\vspace{0.3cm}
\textbf{transferAndCall() Pattern:}
\begin{lstlisting}
function transferAndCall(address to, uint256 value, bytes calldata data)
    external returns (bool) {
    transfer(to, value);
    // Call recipient contract's onTokenTransfer() function
    require(to.call(abi.encodeWithSignature("onTokenTransfer(address,uint256,bytes)",
            msg.sender, value, data)));
    return true;
}
\end{lstlisting}

\vspace{0.2cm}
\textbf{Use Case:} Single transaction to send LINK and trigger oracle request
\end{frame}

\begin{frame}{Token Economics: Minting Strategies}
\textbf{Common minting approaches:}

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{Fixed Supply (e.g., Bitcoin, LINK):}
\begin{itemize}
\item All tokens minted at deployment
\item No future minting possible
\item Deflationary if burning is enabled
\end{itemize}

\item \textbf{Owner-Controlled Minting (e.g., USDC):}
\begin{itemize}
\item Authorized addresses can mint
\item Requires trust in minter
\item Used for stablecoins (mint when fiat deposited)
\end{itemize}

\item \textbf{Algorithmic Minting (e.g., DAI, UNI):}
\begin{itemize}
\item Minting via smart contract logic
\item No human discretion
\item DAI: Mint by depositing collateral
\item UNI: Minted via liquidity mining rewards
\end{itemize}

\item \textbf{Inflationary Rewards (e.g., staking tokens):}
\begin{itemize}
\item Continuous minting at fixed rate
\item Distributed to stakers/validators
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Token Economics: Burning Strategies}
\textbf{Why burn tokens?}

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{Reduce Supply:}
\begin{itemize}
\item Increase scarcity and potentially value
\item Example: BNB quarterly burns (Binance uses profits to buy back and burn)
\end{itemize}

\item \textbf{Stablecoin Redemption:}
\begin{itemize}
\item Burn when user redeems for fiat
\item Example: USDC burn when user withdraws USD
\end{itemize}

\item \textbf{Fee Burning (EIP-1559 model):}
\begin{itemize}
\item ETH burns base fee to reduce supply
\item Some tokens adopt similar mechanics
\end{itemize}

\item \textbf{Proof of Burn:}
\begin{itemize}
\item Destroy tokens on one chain to mint on another
\item Used in cross-chain bridges
\end{itemize}
\end{enumerate}

\vspace{0.3cm}
\begin{lstlisting}
function burn(uint256 amount) public {
    _burn(msg.sender, amount);  // Decrease balance and totalSupply
}
\end{lstlisting}
\end{frame}

\begin{frame}{ERC-20 Variants and Improvements}
\textbf{Extensions to standard ERC-20:}

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{EIP-2612 (Permit):}
\begin{itemize}
\item Approve via off-chain signature (meta-transactions)
\item Saves one transaction for users
\item Used by DAI, USDC
\end{itemize}

\item \textbf{ERC-20 Snapshot:}
\begin{itemize}
\item Capture token balances at specific block
\item Used for governance voting (prevent double voting)
\end{itemize}

\item \textbf{ERC-20 Votes:}
\begin{itemize}
\item Delegation of voting power
\item Used by UNI, COMP governance tokens
\end{itemize}

\item \textbf{Rebase Tokens (e.g., Ampleforth):}
\begin{itemize}
\item Token balance changes automatically based on price
\item Non-standard, breaks ERC-20 assumptions
\end{itemize}

\item \textbf{Wrapped Tokens (e.g., WETH):}
\begin{itemize}
\item ERC-20 wrapper around native ETH
\item Enables ETH to be used in ERC-20 contracts
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}{Key Takeaways}
\begin{enumerate}
\item \textbf{ERC-20 Standard:} Defines common interface for fungible tokens, enabling ecosystem-wide interoperability

\item \textbf{Core Functions:} totalSupply, balanceOf, transfer, approve, allowance, transferFrom

\item \textbf{Allowance Mechanism:} Two-step approve + transferFrom enables smart contracts to spend user tokens

\item \textbf{Security:} Use OpenZeppelin implementation, beware of approve race condition and reentrancy

\item \textbf{Decimals:} Tokens stored as integers, decimals defines display precision (convention: 18)

\item \textbf{Real-World Usage:} USDC (centralized, 6 decimals, blacklist), DAI (decentralized, 18 decimals, permit), LINK (fixed supply, transferAndCall)

\item \textbf{Token Economics:} Minting strategies (fixed, controlled, algorithmic) and burning (scarcity, redemption, fee model)
\end{enumerate}
\end{frame}

\begin{frame}{Discussion Questions}
\begin{enumerate}
\item Why do stablecoins like USDC use 6 decimals instead of 18?

\item What are the security tradeoffs between approving a limited amount vs infinite approval for DEX trading?

\item How does the EIP-2612 permit() function improve user experience compared to standard approve()?

\item What are the regulatory implications of USDC's blacklist function compared to DAI's permissionless design?

\item How might fee-on-transfer tokens break assumptions in DEX contracts or other DeFi protocols?
\end{enumerate}
\end{frame}

\begin{frame}{Next Lesson Preview: L18 - ERC-721 and ERC-1155 Standards}
\textbf{Coming up next:}
\begin{itemize}
\item Non-fungible tokens (NFTs) and the ERC-721 standard
\item ownerOf, tokenURI, safeTransferFrom functions
\item Metadata standards and IPFS integration
\item ERC-1155 multi-token standard (fungible + non-fungible)
\item Batch operations and gas efficiency
\item Real-world examples: CryptoPunks, Bored Apes, ENS domains
\end{itemize}

\vspace{0.3cm}
\textbf{Preparation:}
\begin{itemize}
\item Browse NFT collections on OpenSea
\item Review ERC-721 interface specification (eips.ethereum.org)
\item Explore IPFS basics (ipfs.io)
\end{itemize}
\end{frame}

\end{document}
