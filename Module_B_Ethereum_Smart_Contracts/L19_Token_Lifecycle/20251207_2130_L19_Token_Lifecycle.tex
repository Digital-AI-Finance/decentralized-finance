\documentclass[8pt,aspectratio=169]{beamer}
\usetheme{Madrid}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
\lstset{basicstyle=\tiny\ttfamily,breaklines=true}

\title{L19: Token Lifecycle Management}
\subtitle{Module B: Ethereum \& Smart Contracts}
\author{Blockchain \& Cryptocurrency Course}
\date{December 2025}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Learning Objectives}
By the end of this lesson, you will be able to:
\begin{itemize}
\item Implement various minting strategies (owner, public, allowlist, merkle tree)
\item Design burning mechanisms for deflationary tokenomics
\item Use Pausable pattern for emergency circuit breakers
\item Apply access control patterns (Ownable, AccessControl, multi-sig)
\item Understand upgradeability patterns (Transparent Proxy, UUPS)
\item Implement time-locked operations and governance mechanisms
\end{itemize}
\end{frame}

\begin{frame}{Token Lifecycle Stages}
\textbf{Complete lifecycle of a token contract:}

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{Deployment:}
\begin{itemize}
\item Contract creation and initialization
\item Owner/admin setup
\item Initial token distribution (or reserve for minting)
\end{itemize}

\item \textbf{Minting:}
\begin{itemize}
\item Creating new tokens (increasing supply)
\item Controlled by governance, owner, or public
\end{itemize}

\item \textbf{Operation:}
\begin{itemize}
\item Normal transfers, approvals, staking
\item May include pause/unpause capability
\end{itemize}

\item \textbf{Burning:}
\begin{itemize}
\item Destroying tokens (decreasing supply)
\item Voluntary or forced mechanisms
\end{itemize}

\item \textbf{Upgrade/Migration:}
\begin{itemize}
\item Proxy upgrades or token swaps
\item Governance-controlled or multi-sig
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Minting Strategy 1: Owner-Controlled}
\textbf{Simple admin-based minting:}

\begin{lstlisting}
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract OwnerMintToken is ERC20, Ownable {
    constructor() ERC20("Owner Mint Token", "OMT") {}

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
\end{lstlisting}

\vspace{0.3cm}
\textbf{Advantages:}
\begin{itemize}
\item Simple implementation
\item Flexible timing and recipients
\item Useful for airdrops, rewards, team allocation
\end{itemize}

\vspace{0.3cm}
\textbf{Disadvantages:}
\begin{itemize}
\item Centralized control (trust in owner)
\item Risk of unlimited inflation
\item Regulatory concerns (security classification)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Minting Strategy 2: Public Mint with Cap}
\textbf{Anyone can mint up to a maximum supply:}

\begin{lstlisting}
contract PublicMintToken is ERC20 {
    uint256 public constant MAX_SUPPLY = 1_000_000 * 10**18;
    uint256 public constant MINT_PRICE = 0.01 ether;
    uint256 public constant MAX_PER_TX = 10 * 10**18;

    constructor() ERC20("Public Mint Token", "PMT") {}

    function mint(uint256 amount) public payable {
        require(totalSupply() + amount <= MAX_SUPPLY, "Max supply exceeded");
        require(amount <= MAX_PER_TX, "Exceeds max per transaction");
        require(msg.value >= amount * MINT_PRICE / 10**18, "Insufficient payment");

        _mint(msg.sender, amount);
    }

    function withdraw() public onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }
}
\end{lstlisting}

\vspace{0.2cm}
\textbf{Use Cases:} NFT mints, fair launch tokens, crowdfunding
\end{frame}

\begin{frame}[fragile]{Minting Strategy 3: Allowlist (Whitelist)}
\textbf{Restrict minting to approved addresses:}

\begin{lstlisting}
contract AllowlistMintToken is ERC20, Ownable {
    mapping(address => bool) public allowlist;
    mapping(address => bool) public hasMinted;

    uint256 public constant MINT_AMOUNT = 100 * 10**18;

    constructor() ERC20("Allowlist Token", "ALT") {}

    function addToAllowlist(address[] calldata addresses) public onlyOwner {
        for (uint i = 0; i < addresses.length; i++) {
            allowlist[addresses[i]] = true;
        }
    }

    function mint() public {
        require(allowlist[msg.sender], "Not on allowlist");
        require(!hasMinted[msg.sender], "Already minted");

        hasMinted[msg.sender] = true;
        _mint(msg.sender, MINT_AMOUNT);
    }
}
\end{lstlisting}

\vspace{0.2cm}
\textbf{Challenge:} Gas-expensive to add large allowlists (20,000 gas per address)
\end{frame}

\begin{frame}[fragile]{Minting Strategy 4: Merkle Tree Allowlist}
\textbf{Gas-efficient allowlist using Merkle proofs:}

\begin{lstlisting}
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

contract MerkleMintToken is ERC20 {
    bytes32 public merkleRoot;
    mapping(address => bool) public hasClaimed;

    constructor(bytes32 _merkleRoot) ERC20("Merkle Token", "MTK") {
        merkleRoot = _merkleRoot;
    }

    function claim(uint256 amount, bytes32[] calldata merkleProof) public {
        require(!hasClaimed[msg.sender], "Already claimed");

        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));
        require(MerkleProof.verify(merkleProof, merkleRoot, leaf), "Invalid proof");

        hasClaimed[msg.sender] = true;
        _mint(msg.sender, amount);
    }
}
\end{lstlisting}

\vspace{0.2cm}
\textbf{Advantages:} Store single root hash (32 bytes) instead of entire allowlist

\textbf{Gas Cost:} Approximately 20,000 gas for root, regardless of allowlist size
\end{frame}

\begin{frame}{Merkle Tree Allowlist Example}
\textbf{Off-chain computation:}

\vspace{0.3cm}
\textbf{Step 1: Create allowlist with amounts}
\begin{itemize}
\item Alice: 100 tokens
\item Bob: 200 tokens
\item Charlie: 150 tokens
\item ... 10,000 more addresses
\end{itemize}

\vspace{0.3cm}
\textbf{Step 2: Build Merkle tree}
\begin{itemize}
\item Leaf 1: \texttt{keccak256(abi.encodePacked(Alice, 100))}
\item Leaf 2: \texttt{keccak256(abi.encodePacked(Bob, 200))}
\item ... hash pairs recursively to build tree
\item \textbf{Root:} \texttt{0xabc123...} (single 32-byte hash)
\end{itemize}

\vspace{0.3cm}
\textbf{Step 3: Deploy contract with root}
\begin{itemize}
\item Store only \texttt{0xabc123...} on-chain (20,000 gas)
\end{itemize}

\vspace{0.3cm}
\textbf{Step 4: Users claim with proof}
\begin{itemize}
\item Alice provides: \texttt{amount=100}, \texttt{proof=[hash2, hash34, hash5678, ...]}
\item Contract verifies proof against root
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Burning Mechanisms}
\textbf{Destroying tokens to reduce supply:}

\begin{lstlisting}
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";

contract BurnableToken is ERC20Burnable {
    constructor() ERC20("Burnable Token", "BURN") {
        _mint(msg.sender, 1_000_000 * 10**18);
    }

    // Inherited from ERC20Burnable:
    // function burn(uint256 amount) public {
    //     _burn(msg.sender, amount);
    // }

    // function burnFrom(address account, uint256 amount) public {
    //     uint256 currentAllowance = allowance(account, msg.sender);
    //     require(currentAllowance >= amount, "Insufficient allowance");
    //     _approve(account, msg.sender, currentAllowance - amount);
    //     _burn(account, amount);
    // }
}
\end{lstlisting}

\vspace{0.2cm}
\textbf{Burn Strategies:}
\begin{itemize}
\item \textbf{Voluntary:} Users burn their own tokens (e.g., for utility)
\item \textbf{Fee Burn:} Transaction fees burned automatically (EIP-1559 model)
\item \textbf{Buyback \& Burn:} Protocol buys tokens from market and burns them
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Deflationary Tokenomics}
\textbf{Design patterns for reducing supply over time:}

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{Transaction Fee Burn:}
\begin{lstlisting}
function _transfer(address from, address to, uint256 amount) internal override {
    uint256 burnAmount = amount * 2 / 100;  // 2% burn on every transfer
    uint256 sendAmount = amount - burnAmount;

    super._transfer(from, address(0), burnAmount);  // Burn
    super._transfer(from, to, sendAmount);          // Transfer remainder
}
\end{lstlisting}

\item \textbf{Staking Burn Requirement:}
\begin{itemize}
\item Users must burn X tokens to stake Y tokens
\item Creates scarcity for staking participation
\end{itemize}

\item \textbf{Governance Proposal Burn:}
\begin{itemize}
\item Burn tokens to submit governance proposal
\item Prevents spam proposals
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Access Control: Ownable Pattern}
\textbf{Single owner with full control:}

\begin{lstlisting}
import "@openzeppelin/contracts/access/Ownable.sol";

contract OwnedToken is ERC20, Ownable {
    constructor() ERC20("Owned Token", "OWN") {}

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    function transferOwnership(address newOwner) public override onlyOwner {
        require(newOwner != address(0), "Invalid new owner");
        super.transferOwnership(newOwner);
    }

    function renounceOwnership() public override onlyOwner {
        // Irreversibly give up ownership (contract becomes unmanaged)
        super.renounceOwnership();
    }
}
\end{lstlisting}

\vspace{0.2cm}
\textbf{Risk:} Single point of failure (owner key compromise = full control loss)

\textbf{Mitigation:} Use multi-sig wallet as owner (Gnosis Safe)
\end{frame}

\begin{frame}{Access Control: Multi-Signature Wallets}
\textbf{Require multiple approvals for critical operations:}

\vspace{0.3cm}
\textbf{Gnosis Safe Example:}
\begin{itemize}
\item 3-of-5 multi-sig: Requires 3 out of 5 owners to approve transaction
\item Prevents single key compromise
\item Common setup: Deploy token with Gnosis Safe as owner
\end{itemize}

\vspace{0.3cm}
\textbf{Workflow:}
\begin{enumerate}
\item Owner 1 proposes transaction (e.g., \texttt{mint(alice, 1000)})
\item Owners 2 and 3 approve transaction
\item Transaction executes automatically when threshold reached
\item Transaction hash logged on-chain for transparency
\end{enumerate}

\vspace{0.3cm}
\textbf{Real-World Usage:}
\begin{itemize}
\item Uniswap: 4-of-7 multi-sig controls protocol fees
\item Compound: Timelock + multi-sig for governance execution
\item Curve: 3-of-5 emergency multi-sig for pausing
\end{itemize}
\end{frame}

\begin{frame}{Upgradeability: Why and Risks}
\textbf{Motivation for upgradeable contracts:}
\begin{itemize}
\item Fix critical bugs without redeploying
\item Add new features (e.g., staking, governance)
\item Migrate to more efficient implementation
\item Comply with changing regulations
\end{itemize}

\vspace{0.3cm}
\textbf{Fundamental Challenge:}
\begin{itemize}
\item Smart contracts are immutable after deployment
\item Bytecode cannot be changed
\end{itemize}

\vspace{0.3cm}
\textbf{Solution: Proxy Pattern}
\begin{itemize}
\item \textbf{Proxy Contract:} Fixed address, users interact with this
\item \textbf{Implementation Contract:} Contains logic, can be swapped
\item Proxy uses \texttt{delegatecall} to execute implementation logic
\end{itemize}

\vspace{0.3cm}
\textbf{Risks:}
\begin{itemize}
\item Admin can rug pull by upgrading to malicious implementation
\item Storage layout collisions between versions
\item Requires trust in upgrade governance
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Upgradeability: Transparent Proxy Pattern}
\textbf{Separate admin and user interfaces:}

\begin{lstlisting}
// Proxy Contract (deployed once, never changes)
contract TransparentProxy {
    address public implementation;
    address public admin;

    constructor(address _implementation) {
        implementation = _implementation;
        admin = msg.sender;
    }

    function upgradeTo(address newImplementation) external {
        require(msg.sender == admin, "Not admin");
        implementation = newImplementation;
    }

    fallback() external payable {
        address impl = implementation;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}{Key Takeaways}
\begin{enumerate}
\item \textbf{Minting Strategies:} Owner-controlled (centralized), public mint (open), allowlist (exclusive), Merkle tree (gas-efficient)

\item \textbf{Burning:} Voluntary burn, fee burn, buyback and burn for deflationary tokenomics

\item \textbf{Pausable:} Emergency circuit breaker halts transfers during critical bugs

\item \textbf{Access Control:} Ownable (single admin), AccessControl (role-based), multi-sig (distributed trust)

\item \textbf{Upgradeability:} Transparent Proxy (separate admin/user), UUPS (upgrade logic in implementation), with storage layout risks

\item \textbf{Timelock:} Delay critical operations to allow community reaction and exit

\item \textbf{Governance:} Token-weighted voting enables decentralized control of protocol parameters
\end{enumerate}
\end{frame}

\begin{frame}{Discussion Questions}
\begin{enumerate}
\item What are the security tradeoffs between Merkle tree allowlists and simple mapping-based allowlists?

\item Should all tokens be pausable, or does this introduce too much centralization risk?

\item How can upgradeable contracts maintain credible neutrality when admins can change the code?

\item What is the optimal timelock delay for different types of governance actions (parameter changes vs emergency actions)?

\item How do deflationary tokenomics (burning) affect long-term protocol sustainability compared to inflationary models?
\end{enumerate}
\end{frame}

\begin{frame}{Next Lesson Preview: L20 - Lab: Token Analysis}
\textbf{Coming up next (hands-on lab):}
\begin{itemize}
\item Analyzing USDC and DAI contracts on Etherscan
\item Examining token holder distribution and centralization
\item Tracking transaction patterns and whale movements
\item Identifying upgrade events and governance actions
\item Deploying your own ERC-20 token with custom features
\item Verifying and interacting with deployed token
\end{itemize}

\vspace{0.3cm}
\textbf{Preparation:}
\begin{itemize}
\item Review Etherscan contract reading interface
\item Familiarize with USDC and DAI token pages
\item Prepare Sepolia testnet ETH for deployment
\end{itemize}
\end{frame}

\end{document}
