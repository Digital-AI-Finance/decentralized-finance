\documentclass[8pt,aspectratio=169]{beamer}
\usetheme{Madrid}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
\lstset{basicstyle=\tiny\ttfamily,breaklines=true}

\title{L15: Solidity Fundamentals}
\subtitle{Module B: Ethereum \& Smart Contracts}
\author{Blockchain \& Cryptocurrency Course}
\date{December 2025}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Learning Objectives}
By the end of this lesson, you will be able to:
\begin{itemize}
\item Understand Solidity's role as a smart contract language
\item Declare and use fundamental data types (uint, address, bool, string, bytes)
\item Write functions with appropriate visibility and state mutability modifiers
\item Implement events for logging and monitoring
\item Use mappings and arrays for data storage
\item Apply inheritance and interfaces
\item Write simple smart contracts (HelloWorld, Counter, SimpleStorage)
\end{itemize}
\end{frame}

\begin{frame}{What is Solidity?}
\textbf{Solidity is a statically-typed, contract-oriented programming language:}

\vspace{0.3cm}
\begin{itemize}
\item Created specifically for Ethereum smart contracts
\item Syntax similar to JavaScript/C++
\item Compiles to EVM bytecode
\item Current stable version: 0.8.x (as of 2025)
\item Developed by Ethereum Foundation
\end{itemize}

\vspace{0.3cm}
\textbf{Key Characteristics:}
\begin{itemize}
\item \textbf{Statically typed:} Types checked at compile time
\item \textbf{Contract-oriented:} Code organized into contracts (like classes)
\item \textbf{Inheritance support:} Multiple inheritance with C3 linearization
\item \textbf{Libraries:} Reusable code without state
\item \textbf{User-defined types:} Structs and enums
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Basic Contract Structure}
\textbf{Every Solidity file starts with a version pragma:}

\begin{lstlisting}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract HelloWorld {
    // State variables
    string public message;

    // Constructor
    constructor(string memory initialMessage) {
        message = initialMessage;
    }

    // Function
    function setMessage(string memory newMessage) public {
        message = newMessage;
    }

    // View function (read-only)
    function getMessage() public view returns (string memory) {
        return message;
    }
}
\end{lstlisting}

\vspace{0.2cm}
\textbf{Key Elements:} License identifier, pragma, contract declaration, state variables, constructor, functions
\end{frame}

\begin{frame}[fragile]{SPDX License Identifier}
\textbf{Required at top of every Solidity file:}

\begin{lstlisting}
// SPDX-License-Identifier: MIT
\end{lstlisting}

\vspace{0.3cm}
\textbf{Common Licenses:}
\begin{itemize}
\item \textbf{MIT:} Permissive open-source license
\item \textbf{GPL-3.0:} Copyleft license (derivatives must be open-source)
\item \textbf{Apache-2.0:} Permissive with patent grant
\item \textbf{UNLICENSED:} Proprietary code
\end{itemize}

\vspace{0.3cm}
\textbf{Version Pragma:}
\begin{itemize}
\item \texttt{pragma solidity \^{}0.8.0;} - Compatible with 0.8.0 to 0.8.x
\item \texttt{pragma solidity >=0.8.0 <0.9.0;} - Range specification
\item \texttt{pragma solidity 0.8.20;} - Exact version
\item Prevents compilation with incompatible compiler versions
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Value Types: Integers and Booleans}
\textbf{Integers:}
\begin{itemize}
\item \texttt{uint} (unsigned): 0 to $2^{256} - 1$ (alias for \texttt{uint256})
\item \texttt{uint8, uint16, ..., uint256}: Sized variants (increments of 8)
\item \texttt{int} (signed): $-2^{255}$ to $2^{255} - 1$ (alias for \texttt{int256})
\item \texttt{int8, int16, ..., int256}: Sized variants
\end{itemize}

\vspace{0.3cm}
\textbf{Booleans:}
\begin{itemize}
\item \texttt{bool}: \texttt{true} or \texttt{false}
\item Operators: \texttt{!} (not), \texttt{\&\&} (and), \texttt{||} (or), \texttt{==}, \texttt{!=}
\end{itemize}

\vspace{0.3cm}
\begin{lstlisting}
contract Types {
    uint256 public largeNumber = 1000000000000000000;  // 1e18
    uint8 public smallNumber = 255;  // Max value for uint8
    int256 public signedNumber = -42;
    bool public isActive = true;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Value Types: Address}
\textbf{Address type holds 20-byte Ethereum addresses:}

\vspace{0.3cm}
\begin{itemize}
\item \texttt{address}: Basic address type
\item \texttt{address payable}: Can receive Ether via \texttt{transfer()} or \texttt{send()}
\end{itemize}

\vspace{0.3cm}
\textbf{Address Members:}
\begin{itemize}
\item \texttt{<address>.balance}: Returns Ether balance (in Wei)
\item \texttt{<address payable>.transfer(uint amount)}: Send Ether, reverts on failure
\item \texttt{<address payable>.send(uint amount)}: Send Ether, returns bool
\item \texttt{<address>.call\{value: amount\}("")}: Low-level call with Ether
\end{itemize}

\vspace{0.3cm}
\begin{lstlisting}
contract AddressExample {
    address public owner;
    address payable public recipient;

    constructor() {
        owner = msg.sender;  // Address of contract deployer
        recipient = payable(msg.sender);  // Convert to payable
    }

    function checkBalance() public view returns (uint) {
        return owner.balance;  // Balance in Wei
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Value Types: Bytes and Strings}
\textbf{Fixed-Size Byte Arrays:}
\begin{itemize}
\item \texttt{bytes1, bytes2, ..., bytes32}: Fixed-size arrays
\item More gas-efficient than dynamic bytes
\item Commonly used for hashes: \texttt{bytes32 public dataHash;}
\end{itemize}

\vspace{0.3cm}
\textbf{Dynamic Types:}
\begin{itemize}
\item \texttt{bytes}: Dynamic byte array
\item \texttt{string}: Dynamic UTF-8 string (no length or index access)
\item More expensive in gas than fixed-size
\end{itemize}

\vspace{0.3cm}
\begin{lstlisting}
contract BytesStrings {
    bytes32 public hash;  // 32 bytes, e.g., for Keccak-256 hash
    bytes public dynamicData;
    string public name = "Alice";

    function setHash(bytes32 _hash) public {
        hash = _hash;
    }

    function concatenate(string memory a, string memory b)
        public pure returns (string memory) {
        return string(abi.encodePacked(a, b));
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Reference Types: Arrays}
\textbf{Fixed-Size Arrays:}
\begin{lstlisting}
uint[5] public fixedArray;  // Array of 5 uints
\end{lstlisting}

\vspace{0.3cm}
\textbf{Dynamic Arrays:}
\begin{lstlisting}
uint[] public dynamicArray;
string[] public names;

function addElement(uint value) public {
    dynamicArray.push(value);  // Append to array
}

function getLength() public view returns (uint) {
    return dynamicArray.length;
}

function removeLastElement() public {
    dynamicArray.pop();  // Remove last element
}
\end{lstlisting}

\vspace{0.3cm}
\textbf{Memory vs Storage Arrays:}
\begin{itemize}
\item \texttt{storage}: Persistent, expensive (state variable)
\item \texttt{memory}: Temporary, cheaper (function scope)
\item \texttt{calldata}: Read-only, cheapest (external function parameters)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Reference Types: Mappings}
\textbf{Key-value storage (like hash tables):}

\vspace{0.3cm}
\begin{lstlisting}
contract MappingExample {
    // Mapping from address to balance
    mapping(address => uint256) public balances;

    // Nested mapping (address to address to allowance)
    mapping(address => mapping(address => uint256)) public allowances;

    function updateBalance(address account, uint256 amount) public {
        balances[account] = amount;
    }

    function getBalance(address account) public view returns (uint256) {
        return balances[account];  // Returns 0 if key doesn't exist
    }

    function approve(address spender, uint256 amount) public {
        allowances[msg.sender][spender] = amount;
    }
}
\end{lstlisting}

\vspace{0.3cm}
\textbf{Key Properties:}
\begin{itemize}
\item All possible keys exist with default value (0 for uint, false for bool)
\item Cannot iterate over mappings (no concept of keys array)
\item Only allowed in storage (not memory or calldata)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Functions: Visibility Modifiers}
\textbf{Four visibility levels:}

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{public:} Callable from anywhere (external and internal)
\begin{itemize}
\item Automatically creates getter for state variables
\end{itemize}

\item \textbf{external:} Only callable from outside contract (via transactions or other contracts)
\begin{itemize}
\item More gas-efficient for large data (uses calldata)
\end{itemize}

\item \textbf{internal:} Only callable within contract or derived contracts (default for state variables)

\item \textbf{private:} Only callable within contract (not derived contracts)
\end{enumerate}

\vspace{0.3cm}
\begin{lstlisting}
contract Visibility {
    uint private secretNumber;
    uint internal internalNumber;

    function publicFunc() public { }           // Anyone can call
    function externalFunc() external { }       // Only external calls
    function internalFunc() internal { }       // This contract + children
    function privateFunc() private { }         // Only this contract
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Functions: State Mutability}
\textbf{Three state mutability levels:}

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{view:} Reads state but doesn't modify it
\begin{itemize}
\item No gas cost when called externally (off-chain)
\item Gas cost when called by another function (on-chain)
\end{itemize}

\item \textbf{pure:} Doesn't read or modify state
\begin{itemize}
\item Can only use function parameters and local variables
\item No gas cost when called externally
\end{itemize}

\item \textbf{(none):} Can read and modify state
\begin{itemize}
\item Costs gas even when called externally
\end{itemize}
\end{enumerate}

\vspace{0.3cm}
\begin{lstlisting}
contract Mutability {
    uint public value = 10;

    function getValue() public view returns (uint) {
        return value;  // Reads state (view)
    }

    function add(uint a, uint b) public pure returns (uint) {
        return a + b;  // No state access (pure)
    }

    function setValue(uint newValue) public {
        value = newValue;  // Modifies state (no modifier)
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Functions: Parameters and Returns}
\textbf{Data Location for Reference Types:}

\begin{lstlisting}
contract DataLocation {
    uint[] public storageArray;  // State variable (storage)

    // calldata: read-only, cheapest for external functions
    function processCalldata(uint[] calldata data) external pure returns (uint) {
        return data[0];  // Can read but not modify
    }

    // memory: temporary, for internal use
    function processMemory(uint[] memory data) public pure returns (uint) {
        data[0] = 999;  // Can modify, but changes don't persist
        return data[0];
    }

    // storage: persistent, modifies state
    function modifyStorage() public {
        storageArray.push(42);  // Changes persist
    }

    // Named return values
    function divide(uint a, uint b) public pure returns (uint quotient, uint remainder) {
        quotient = a / b;
        remainder = a % b;
        // Implicit return of named values
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Events}
\textbf{Events enable logging for off-chain monitoring:}

\vspace{0.3cm}
\begin{lstlisting}
contract EventExample {
    // Declare events
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    mapping(address => uint256) public balances;

    function transfer(address to, uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");

        balances[msg.sender] -= amount;
        balances[to] += amount;

        // Emit event
        emit Transfer(msg.sender, to, amount);
    }
}
\end{lstlisting}

\vspace{0.3cm}
\textbf{Indexed Parameters:}
\begin{itemize}
\item Up to 3 parameters can be \texttt{indexed}
\item Indexed parameters become searchable topics
\item Enables efficient filtering (e.g., ``all transfers to address X'')
\item Non-indexed parameters stored in log data
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Error Handling: require, assert, revert}
\textbf{Three error handling mechanisms:}

\vspace{0.3cm}
\begin{enumerate}
\item \textbf{require(condition, message):} Validate inputs/conditions
\begin{itemize}
\item Refunds remaining gas if fails
\item Use for user input validation
\end{itemize}

\item \textbf{assert(condition):} Check invariants (should never fail)
\begin{itemize}
\item Consumes all gas if fails (pre-0.8.0, now refunds)
\item Use for internal errors
\end{itemize}

\item \textbf{revert(message):} Unconditional revert
\begin{itemize}
\item Refunds remaining gas
\item Use in complex conditional logic
\end{itemize}
\end{enumerate}

\vspace{0.3cm}
\begin{lstlisting}
function transfer(address to, uint amount) public {
    require(to != address(0), "Cannot transfer to zero address");
    require(balances[msg.sender] >= amount, "Insufficient balance");

    balances[msg.sender] -= amount;
    balances[to] += amount;

    assert(balances[msg.sender] + balances[to] == totalSupply);  // Invariant
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Custom Errors (Solidity 0.8.4+)}
\textbf{More gas-efficient than string error messages:}

\vspace{0.3cm}
\begin{lstlisting}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

contract CustomErrors {
    error InsufficientBalance(uint requested, uint available);
    error Unauthorized(address caller);

    mapping(address => uint) public balances;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function withdraw(uint amount) public {
        if (msg.sender != owner) {
            revert Unauthorized(msg.sender);
        }

        if (balances[msg.sender] < amount) {
            revert InsufficientBalance(amount, balances[msg.sender]);
        }

        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
}
\end{lstlisting}

\vspace{0.2cm}
\textbf{Benefits:} Lower gas cost, typed parameters, better error context
\end{frame}

\begin{frame}[fragile]{Modifiers}
\textbf{Reusable code for function preconditions:}

\vspace{0.3cm}
\begin{lstlisting}
contract ModifierExample {
    address public owner;
    bool public paused = false;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;  // Placeholder for function body
    }

    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    function pause() public onlyOwner {
        paused = true;
    }

    function unpause() public onlyOwner {
        paused = false;
    }

    function criticalFunction() public onlyOwner whenNotPaused {
        // Only owner can call, and only when not paused
        // ...
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Inheritance}
\textbf{Solidity supports multiple inheritance:}

\vspace{0.3cm}
\begin{lstlisting}
contract Ownable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
}

contract Pausable is Ownable {
    bool public paused;

    function pause() public onlyOwner {
        paused = true;
    }
}

contract MyContract is Pausable {
    function doSomething() public onlyOwner {
        // Inherits owner, onlyOwner, paused, pause()
    }
}
\end{lstlisting}

\vspace{0.3cm}
\textbf{Key Concepts:}
\begin{itemize}
\item \texttt{is} keyword for inheritance
\item \texttt{virtual} and \texttt{override} for function overriding
\item C3 linearization for multiple inheritance
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Interfaces}
\textbf{Define contract structure without implementation:}

\vspace{0.3cm}
\begin{lstlisting}
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
}

contract MyToken is IERC20 {
    mapping(address => uint256) private _balances;
    uint256 private _totalSupply;

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address to, uint256 amount) public override returns (bool) {
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Example: Counter Contract}
\textbf{Simple contract with increment/decrement functionality:}

\vspace{0.3cm}
\begin{lstlisting}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Counter {
    uint256 private count;
    address public owner;

    event CountChanged(uint256 newCount, address changedBy);

    constructor() {
        owner = msg.sender;
        count = 0;
    }

    function increment() public {
        count += 1;
        emit CountChanged(count, msg.sender);
    }

    function decrement() public {
        require(count > 0, "Counter cannot go below zero");
        count -= 1;
        emit CountChanged(count, msg.sender);
    }

    function getCount() public view returns (uint256) {
        return count;
    }

    function reset() public {
        require(msg.sender == owner, "Only owner can reset");
        count = 0;
        emit CountChanged(count, msg.sender);
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}{Key Takeaways}
\begin{enumerate}
\item \textbf{Solidity Basics:} Statically-typed, contract-oriented language compiling to EVM bytecode

\item \textbf{Data Types:} Value types (uint, address, bool, bytes) and reference types (arrays, mappings, structs)

\item \textbf{Visibility:} public, external, internal, private determine who can call functions

\item \textbf{State Mutability:} view (read-only), pure (no state access), or default (state modification)

\item \textbf{Events:} Cheap logging mechanism with indexed parameters for efficient searching

\item \textbf{Error Handling:} require (validation), assert (invariants), revert (conditional), custom errors (gas-efficient)

\item \textbf{Modifiers:} Reusable precondition checks (e.g., onlyOwner, whenNotPaused)

\item \textbf{Inheritance:} Supports multiple inheritance with virtual/override for polymorphism
\end{enumerate}
\end{frame}

\begin{frame}{Discussion Questions}
\begin{enumerate}
\item Why is \texttt{string} more expensive than \texttt{bytes32} for storing short text?

\item When should you use \texttt{external} vs \texttt{public} for function visibility?

\item Why can't you iterate over a mapping's keys in Solidity?

\item What are the tradeoffs between using events vs storing data in state variables for historical records?

\item How does the \texttt{indexed} keyword in events affect gas costs and queryability?
\end{enumerate}
\end{frame}

\begin{frame}{Next Lesson Preview: L16 - Lab: Contract Interaction}
\textbf{Coming up next (hands-on lab):}
\begin{itemize}
\item Introduction to Remix IDE
\item Deploying SimpleStorage contract
\item Interacting with deployed contracts (read/write functions)
\item Using MetaMask with test networks
\item Deploying to Sepolia testnet
\item Verifying contracts on Etherscan
\end{itemize}

\vspace{0.3cm}
\textbf{Preparation:}
\begin{itemize}
\item Install MetaMask browser extension
\item Create Ethereum account and save recovery phrase
\item Get Sepolia testnet ETH from faucet (sepoliafaucet.com)
\item Bookmark remix.ethereum.org
\end{itemize}
\end{frame}

\end{document}
