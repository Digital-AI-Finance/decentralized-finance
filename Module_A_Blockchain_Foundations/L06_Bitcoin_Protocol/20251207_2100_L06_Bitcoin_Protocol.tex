\documentclass[8pt,aspectratio=169]{beamer}
\usetheme{Madrid}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsmath}

\title{Bitcoin Protocol Deep Dive}
\subtitle{BSc Blockchain, Crypto Economy \& NFTs}
\author{Course Instructor}
\date{Module A: Blockchain Foundations}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Learning Objectives}
By the end of this lesson, you will be able to:
\begin{itemize}
    \item Explain the UTXO (Unspent Transaction Output) model
    \item Describe the structure of a Bitcoin transaction
    \item Understand transaction inputs and outputs
    \item Recognize different Bitcoin Script types
    \item Trace the lifecycle of a transaction from creation to confirmation
    \item Distinguish between legacy and SegWit transaction formats
\end{itemize}
\end{frame}

\begin{frame}{The UTXO Model: Core Concept}
\textbf{What is a UTXO?}
\begin{itemize}
    \item Unspent Transaction Output = a chunk of bitcoin that can be spent
    \item Bitcoin does not track account balances (unlike Ethereum)
    \item Instead, tracks individual ``coins'' (UTXOs)
    \item Your wallet balance = sum of all UTXOs you can spend
\end{itemize}

\vspace{0.3cm}
\textbf{Analogy: Physical Cash}
\begin{itemize}
    \item UTXOs are like bills in your wallet
    \item You do not have ``100 EUR balance'' -- you have five 20 EUR bills
    \item To pay 30 EUR: give one 20 EUR bill + one 10 EUR bill
    \item To pay 25 EUR with a 50 EUR bill: receive 25 EUR change
\end{itemize}

\vspace{0.3cm}
\textbf{Key Principle:}
\begin{itemize}
    \item Each UTXO can only be spent once
    \item Spending a UTXO creates new UTXOs
    \item Blockchain tracks which UTXOs are unspent
\end{itemize}
\end{frame}

\begin{frame}{UTXO Model vs. Account Model}
\begin{columns}[T]
\begin{column}{0.48\textwidth}
\textbf{UTXO Model (Bitcoin)}
\begin{itemize}
    \item No account balances
    \item Each transaction consumes old UTXOs, creates new ones
    \item Stateless verification
    \item Better privacy (new address per transaction)
    \item Parallel transaction processing
\end{itemize}

\vspace{0.3cm}
\textbf{Example:}
\begin{itemize}
    \item Alice has UTXOs: 3 BTC, 2 BTC
    \item Sends 4 BTC to Bob
    \item Consumes both UTXOs (5 BTC total)
    \item Creates: 4 BTC to Bob, 1 BTC change to Alice
\end{itemize}
\end{column}

\begin{column}{0.48\textwidth}
\textbf{Account Model (Ethereum)}
\begin{itemize}
    \item Global account balances
    \item Transactions modify balances
    \item Stateful verification (need current balance)
    \item Simpler mental model
    \item Sequential nonces prevent replay
\end{itemize}

\vspace{0.3cm}
\textbf{Example:}
\begin{itemize}
    \item Alice account: 5 ETH
    \item Sends 4 ETH to Bob
    \item Deduct from Alice: 5 - 4 = 1 ETH
    \item Add to Bob: 0 + 4 = 4 ETH
\end{itemize}
\end{column}
\end{columns}

\vspace{0.4cm}
\textbf{Why Bitcoin Uses UTXO:}
\begin{itemize}
    \item Easier to verify transaction validity (check UTXO existence)
    \item No global state required for validation
    \item Natural double-spend prevention
\end{itemize}
\end{frame}

\begin{frame}{Bitcoin Transaction Structure}
\textbf{High-Level Components:}

\vspace{0.3cm}
\begin{enumerate}
    \item \textbf{Version:} Protocol version number (currently 1 or 2)
    \item \textbf{Inputs:} List of UTXOs being spent
    \item \textbf{Outputs:} List of new UTXOs being created
    \item \textbf{Locktime:} Earliest block height or timestamp when transaction is valid (usually 0)
\end{enumerate}

\vspace{0.3cm}
\textbf{Transaction Hash (txid):}
\begin{itemize}
    \item Double SHA-256 of entire transaction
    \item Unique identifier (e.g., \texttt{a1b2c3d4...})
    \item Used to reference transaction in inputs
\end{itemize}

\vspace{0.3cm}
\textbf{Size and Fees:}
\begin{itemize}
    \item Transaction size measured in bytes (not kilobytes)
    \item Fee = size $\times$ fee rate (satoshis per byte)
    \item Miners prioritize higher fee-rate transactions
    \item Typical transaction: 200-400 bytes
\end{itemize}
\end{frame}

\begin{frame}{Transaction Inputs}
\textbf{Each Input Contains:}

\vspace{0.3cm}
\begin{enumerate}
    \item \textbf{Previous Transaction Hash:} txid of transaction containing UTXO
    \item \textbf{Output Index:} which output from previous transaction (0, 1, 2, ...)
    \item \textbf{ScriptSig (Unlocking Script):} provides signature and public key
    \item \textbf{Sequence Number:} originally for transaction replacement (now mostly unused)
\end{enumerate}

\vspace{0.3cm}
\textbf{Example Input:}
\begin{itemize}
    \item Previous tx: \texttt{5a3c7b...} (Alice received 3 BTC)
    \item Output index: 0 (first output of that transaction)
    \item ScriptSig: signature proving Alice owns the UTXO
\end{itemize}

\vspace{0.3cm}
\textbf{Multiple Inputs:}
\begin{itemize}
    \item Transaction can have many inputs
    \item Allows combining multiple UTXOs
    \item Each input must be signed separately
    \item Example: combine 1 BTC + 2 BTC + 1.5 BTC = 4.5 BTC total
\end{itemize}
\end{frame}

\begin{frame}{Transaction Outputs}
\textbf{Each Output Contains:}

\vspace{0.3cm}
\begin{enumerate}
    \item \textbf{Value:} Amount of satoshis (1 BTC = 100,000,000 satoshis)
    \item \textbf{ScriptPubKey (Locking Script):} conditions to spend this output
\end{enumerate}

\vspace{0.3cm}
\textbf{Example Output:}
\begin{itemize}
    \item Value: 4,000,000,000 satoshis (40 BTC)
    \item ScriptPubKey: ``Pay to Bob's public key hash''
\end{itemize}

\vspace{0.3cm}
\textbf{Change Outputs:}
\begin{itemize}
    \item When input value > payment amount, create change output
    \item Change goes back to sender (usually new address for privacy)
    \item Example: Spend 5 BTC UTXO to send 3 BTC -> create 3 BTC to recipient + 1.999 BTC change (0.001 BTC fee)
\end{itemize}

\vspace{0.3cm}
\textbf{Transaction Fee:}
\begin{itemize}
    \item Fee = Sum of inputs - Sum of outputs
    \item Not explicitly stated in transaction
    \item Miner collects the difference
\end{itemize}
\end{frame}

\begin{frame}{Bitcoin Script: A Stack-Based Language}
\textbf{What is Bitcoin Script?}
\begin{itemize}
    \item Simple, stack-based programming language
    \item Not Turing-complete (no loops, limited expressiveness)
    \item Executed during transaction validation
    \item Determines whether transaction is valid
\end{itemize}

\vspace{0.3cm}
\textbf{How It Works:}
\begin{enumerate}
    \item Combine ScriptSig (from input) + ScriptPubKey (from previous output)
    \item Execute script operations left to right
    \item Use a stack (LIFO data structure)
    \item Transaction valid if final stack value is TRUE
\end{enumerate}

\vspace{0.3cm}
\textbf{Basic Operations:}
\begin{itemize}
    \item \texttt{OP\_DUP}: duplicate top stack item
    \item \texttt{OP\_HASH160}: hash top stack item with SHA-256 then RIPEMD-160
    \item \texttt{OP\_EQUALVERIFY}: check if top two items equal, fail if not
    \item \texttt{OP\_CHECKSIG}: verify signature against public key
\end{itemize}
\end{frame}

\begin{frame}[fragile]{P2PKH: Pay-to-Public-Key-Hash}
\textbf{Most Common Transaction Type:}

\vspace{0.3cm}
\textbf{ScriptPubKey (Locking Script):}
\begin{verbatim}
OP_DUP OP_HASH160 <PubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
\end{verbatim}

\vspace{0.3cm}
\textbf{ScriptSig (Unlocking Script):}
\begin{verbatim}
<Signature> <PubKey>
\end{verbatim}

\vspace{0.3cm}
\textbf{Execution Steps:}
\begin{enumerate}
    \item Push signature and public key onto stack
    \item \texttt{OP\_DUP}: duplicate public key
    \item \texttt{OP\_HASH160}: hash one copy of public key
    \item Compare hash with \texttt{<PubKeyHash>} from ScriptPubKey
    \item \texttt{OP\_EQUALVERIFY}: verify they match
    \item \texttt{OP\_CHECKSIG}: verify signature with remaining public key
    \item Stack contains TRUE -> transaction valid
\end{enumerate}

\vspace{0.3cm}
\textbf{Why Use Public Key Hash Instead of Public Key Directly?}
\begin{itemize}
    \item Shorter addresses (20 bytes vs 33 bytes)
    \item Extra layer of security (quantum resistance)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{P2SH: Pay-to-Script-Hash}
\textbf{Purpose:}
\begin{itemize}
    \item Allows complex spending conditions (multi-signature, time-locks, etc.)
    \item Hides complexity until spending time
    \item Sender only needs recipient's P2SH address
\end{itemize}

\vspace{0.3cm}
\textbf{ScriptPubKey:}
\begin{verbatim}
OP_HASH160 <ScriptHash> OP_EQUAL
\end{verbatim}

\vspace{0.3cm}
\textbf{ScriptSig:}
\begin{verbatim}
<Signature1> <Signature2> ... <RedeemScript>
\end{verbatim}

\vspace{0.3cm}
\textbf{Verification Process:}
\begin{enumerate}
    \item Hash the redeem script
    \item Verify hash matches ScriptHash in ScriptPubKey
    \item Execute redeem script with provided signatures
    \item Transaction valid if redeem script evaluates to TRUE
\end{enumerate}

\vspace{0.3cm}
\textbf{Example: 2-of-3 Multi-Signature:}
\begin{itemize}
    \item Redeem script requires 2 signatures out of 3 possible keys
    \item Spender provides 2 signatures + redeem script
    \item Network verifies both signatures are valid
\end{itemize}
\end{frame}

\begin{frame}{SegWit: Segregated Witness}
\textbf{Problem with Legacy Transactions:}
\begin{itemize}
    \item Signature data (witness) included in transaction hash
    \item Enables transaction malleability: signature can be modified without invalidating transaction
    \item Prevents secure second-layer solutions (Lightning Network)
    \item Wastes block space (signatures are large)
\end{itemize}

\vspace{0.3cm}
\textbf{SegWit Solution (BIP 141, activated 2017):}
\begin{itemize}
    \item Separate signature data from transaction data
    \item Signature moved to separate ``witness'' field
    \item Transaction hash excludes witness (fixes malleability)
    \item Witness data discounted in block size calculation (enables more transactions per block)
\end{itemize}

\vspace{0.3cm}
\textbf{Address Formats:}
\begin{itemize}
    \item P2WPKH (native SegWit): starts with ``bc1q'' (Bech32 encoding)
    \item P2SH-wrapped SegWit: starts with ``3'' (backward compatible)
    \item Example: \texttt{bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4}
\end{itemize}
\end{frame}

\begin{frame}{SegWit Benefits}
\textbf{Block Capacity Increase:}
\begin{itemize}
    \item Legacy: 1 MB block size limit
    \item SegWit: measured in ``weight units'' (max 4 million)
    \item Witness data: 1 byte = 1 weight unit
    \item Non-witness data: 1 byte = 4 weight units
    \item Effective capacity: ~2-2.7 MB per block (depending on transaction types)
\end{itemize}

\vspace{0.3cm}
\textbf{Lower Transaction Fees:}
\begin{itemize}
    \item Witness data discounted by 75\%
    \item Same transaction costs less with SegWit
    \item Incentivizes SegWit adoption
\end{itemize}

\vspace{0.3cm}
\textbf{Enables Lightning Network:}
\begin{itemize}
    \item Fixes transaction malleability
    \item Allows secure off-chain payment channels
    \item Instant, low-fee micropayments
\end{itemize}

\vspace{0.3cm}
\textbf{Script Versioning:}
\begin{itemize}
    \item Enables future upgrades (e.g., Taproot/SegWit v1)
    \item Soft fork compatibility
\end{itemize}
\end{frame}

\begin{frame}{Taproot: SegWit v1 (Activated 2021)}
\textbf{Key Improvements:}

\vspace{0.3cm}
\begin{itemize}
    \item \textbf{Schnorr Signatures:} replace ECDSA
    \begin{itemize}
        \item More efficient (smaller signatures)
        \item Enable signature aggregation
        \item Better privacy (multi-sig looks like single-sig)
    \end{itemize}

    \item \textbf{MAST (Merklized Abstract Syntax Trees):}
    \begin{itemize}
        \item Complex scripts hidden until execution
        \item Only reveal executed branch
        \item Smaller transaction size for complex scripts
    \end{itemize}

    \item \textbf{Privacy Enhancements:}
    \begin{itemize}
        \item All transactions look similar on-chain
        \item Multi-sig indistinguishable from single-sig
        \item Complex smart contracts look like simple payments
    \end{itemize}
\end{itemize}

\vspace{0.3cm}
\textbf{Address Format:}
\begin{itemize}
    \item Starts with ``bc1p'' (Bech32m encoding)
    \item Example: \texttt{bc1p5d7rjq7g6rdk2yhzks9smlaqtedr4dekq08ge8ztwac72sfr9rusxg3297}
\end{itemize}
\end{frame}

\begin{frame}{Transaction Lifecycle: Step by Step}
\textbf{1. Transaction Creation:}
\begin{itemize}
    \item Wallet selects UTXOs to spend
    \item Constructs inputs and outputs
    \item Calculates appropriate fee
    \item Creates change output if necessary
\end{itemize}

\vspace{0.3cm}
\textbf{2. Transaction Signing:}
\begin{itemize}
    \item Wallet signs each input with corresponding private key
    \item Signature proves ownership of UTXOs
    \item Transaction now ready for broadcast
\end{itemize}

\vspace{0.3cm}
\textbf{3. Broadcast to Network:}
\begin{itemize}
    \item Wallet sends transaction to connected Bitcoin nodes
    \item Nodes validate transaction (syntax, signatures, UTXO existence)
    \item Valid transaction added to mempool (memory pool)
    \item Nodes relay transaction to peers (propagation)
\end{itemize}
\end{frame}

\begin{frame}{Transaction Lifecycle: Continued}
\textbf{4. Mempool:}
\begin{itemize}
    \item Holding area for unconfirmed transactions
    \item Each node maintains its own mempool
    \item Transactions sorted by fee rate
    \item Miners select transactions for next block from mempool
\end{itemize}

\vspace{0.3cm}
\textbf{5. Mining and Confirmation:}
\begin{itemize}
    \item Miner includes transaction in candidate block
    \item Miner solves proof-of-work puzzle
    \item Block broadcast to network
    \item Nodes validate block and add to blockchain
    \item Transaction receives first confirmation
\end{itemize}

\vspace{0.3cm}
\textbf{6. Additional Confirmations:}
\begin{itemize}
    \item Each new block adds one confirmation
    \item 6 confirmations typically considered final (~1 hour)
    \item Transaction becomes increasingly irreversible
    \item UTXOs consumed by transaction are now spent
    \item New UTXOs created can now be spent by recipients
\end{itemize}
\end{frame}

\begin{frame}{Transaction Validation Rules}
\textbf{Syntax Validation:}
\begin{itemize}
    \item Transaction size within limits
    \item Output values non-negative
    \item Output values do not exceed input values
    \item No duplicate inputs (double-spend within transaction)
\end{itemize}

\vspace{0.3cm}
\textbf{Semantic Validation:}
\begin{itemize}
    \item All referenced UTXOs exist and are unspent
    \item Signatures valid for all inputs
    \item Script execution succeeds for all inputs
    \item Transaction fee is non-negative
    \item Locktime constraints satisfied
\end{itemize}

\vspace{0.3cm}
\textbf{Contextual Validation:}
\begin{itemize}
    \item UTXOs not already spent in blockchain
    \item No conflicting transaction in mempool
    \item Sufficient fee for mempool acceptance
\end{itemize}

\vspace{0.3cm}
\textbf{Rejection Reasons:}
\begin{itemize}
    \item Invalid signature -> likely fraud attempt
    \item Double-spend -> UTXO already spent
    \item Dust output -> output value too small (spam prevention)
\end{itemize}
\end{frame}

\begin{frame}{Replace-by-Fee (RBF)}
\textbf{Problem:}
\begin{itemize}
    \item Transaction stuck in mempool with low fee
    \item Need to increase fee to speed up confirmation
\end{itemize}

\vspace{0.3cm}
\textbf{RBF Solution (BIP 125):}
\begin{itemize}
    \item Create replacement transaction with same inputs
    \item Increase fee by at least 1 satoshi per byte
    \item Signal RBF by setting sequence number < 0xfffffffe
    \item Nodes replace old transaction with new one in mempool
\end{itemize}

\vspace{0.3cm}
\textbf{Use Cases:}
\begin{itemize}
    \item Fee bump: increase fee when network congested
    \item Output modification: change recipient or amount (before confirmation)
    \item Cancel transaction: send funds back to yourself with higher fee
\end{itemize}

\vspace{0.3cm}
\textbf{Limitations:}
\begin{itemize}
    \item Only works for unconfirmed transactions
    \item Recipient should wait for confirmation before accepting payment
    \item Not all wallets support RBF
\end{itemize}
\end{frame}

\begin{frame}{Child-Pays-for-Parent (CPFP)}
\textbf{Alternative Fee Bumping Method:}

\vspace{0.3cm}
\textbf{Scenario:}
\begin{itemize}
    \item Alice sends low-fee transaction to Bob
    \item Transaction stuck in mempool
    \item Bob wants faster confirmation
\end{itemize}

\vspace{0.3cm}
\textbf{CPFP Mechanism:}
\begin{itemize}
    \item Bob creates new transaction spending Alice's unconfirmed output
    \item Bob's transaction has high fee
    \item Miners must include Alice's transaction to mine Bob's
    \item Combined fee rate makes both transactions attractive
    \item Miner includes both in same block
\end{itemize}

\vspace{0.3cm}
\textbf{Comparison with RBF:}
\begin{itemize}
    \item RBF: sender bumps fee
    \item CPFP: receiver bumps fee
    \item RBF requires original transaction to signal support
    \item CPFP works for any transaction
\end{itemize}
\end{frame}

\begin{frame}{Coinbase Transactions}
\textbf{Special Transaction Type:}

\vspace{0.3cm}
\textbf{Unique Properties:}
\begin{itemize}
    \item First transaction in every block
    \item No inputs (creates new bitcoins)
    \item Miner collects block reward + transaction fees
    \item Must wait 100 confirmations before spending (maturity rule)
\end{itemize}

\vspace{0.3cm}
\textbf{Structure:}
\begin{itemize}
    \item Input: special coinbase input (previous tx hash = all zeros)
    \item ScriptSig: arbitrary data (often miner identification)
    \item Output: block reward + fees to miner address
\end{itemize}

\vspace{0.3cm}
\textbf{Block Reward Schedule:}
\begin{itemize}
    \item Genesis block (2009): 50 BTC
    \item Halving every 210,000 blocks (~4 years)
    \item Current (2024): 6.25 BTC
    \item Next halving (2024): 3.125 BTC
    \item Final halving (~2140): block reward becomes zero
    \item Total supply: 21 million BTC
\end{itemize}
\end{frame}

\begin{frame}{Transaction Fees: Economics}
\textbf{Fee Market Dynamics:}
\begin{itemize}
    \item Block space is scarce (limited to ~4 MB weight per 10 minutes)
    \item Users compete for inclusion via fees
    \item Miners prioritize highest fee-rate transactions
    \item Fee rates fluctuate based on demand
\end{itemize}

\vspace{0.3cm}
\textbf{Fee Estimation:}
\begin{itemize}
    \item Wallets estimate fee based on mempool state
    \item Target confirmation time: 1 block (high fee), 6 blocks (medium), 24 blocks (low)
    \item Fee estimation services: mempool.space, bitcoinfees.earn.com
\end{itemize}

\vspace{0.3cm}
\textbf{Historical Fee Trends:}
\begin{itemize}
    \item Low congestion: < 1 sat/vbyte (< 0.10 USD per transaction)
    \item Moderate congestion: 10-50 sat/vbyte (1-5 USD)
    \item High congestion (bull market): 100-500 sat/vbyte (10-50 USD)
    \item Extreme congestion (2017, 2021): > 1000 sat/vbyte (> 50 USD)
\end{itemize}

\vspace{0.3cm}
\textbf{Future: Layer 2 Solutions}
\begin{itemize}
    \item Lightning Network for micropayments
    \item Liquid Network for faster settlements
    \item Reduce on-chain transaction pressure
\end{itemize}
\end{frame}

\begin{frame}{Key Takeaways}
\begin{itemize}
    \item Bitcoin uses the UTXO model: transactions consume old outputs and create new ones
    \item Each transaction has inputs (UTXOs being spent) and outputs (new UTXOs)
    \item Bitcoin Script enables flexible spending conditions without Turing completeness
    \item P2PKH (legacy), P2SH (multi-sig), SegWit, and Taproot offer increasing efficiency and privacy
    \item Transaction lifecycle: creation -> signing -> broadcast -> mempool -> mining -> confirmation
    \item Fees determined by market competition for block space
    \item SegWit and Taproot improve scalability and privacy
\end{itemize}

\vspace{0.4cm}
\textbf{Design Philosophy:}

Bitcoin prioritizes security and decentralization over transaction throughput. The UTXO model, simple scripting language, and conservative upgrade approach ensure long-term stability and auditability.
\end{frame}

\begin{frame}{Discussion Questions}
\begin{enumerate}
    \item Why does Bitcoin use the UTXO model instead of the account model like Ethereum?

    \item How does the fee market incentivize miners to include transactions in blocks?

    \item What are the trade-offs between using legacy addresses, SegWit, and Taproot?

    \item How does transaction malleability affect second-layer solutions like Lightning?

    \item Why is the coinbase maturity rule (100 confirmations) necessary?

    \item How could you design a transaction that can only be spent after a certain date?
\end{enumerate}
\end{frame}

\begin{frame}{Next Lesson Preview: L07 Proof of Work Consensus}
\textbf{Topics to be covered:}
\begin{itemize}
    \item Mining mechanics and the proof-of-work algorithm
    \item Nonce searching and difficulty adjustment
    \item Block header structure
    \item Mining difficulty and hash rate
    \item Block rewards and the halving schedule
    \item 51\% attacks and mining centralization risks
    \item Energy consumption and environmental concerns
\end{itemize}

\vspace{0.5cm}
\textbf{Preparation:}
\begin{itemize}
    \item Review hash function properties (pre-image resistance)
    \item Explore Bitcoin mining pools and hash rate distribution
    \item Consider the economics of mining profitability
\end{itemize}
\end{frame}

\end{document}
