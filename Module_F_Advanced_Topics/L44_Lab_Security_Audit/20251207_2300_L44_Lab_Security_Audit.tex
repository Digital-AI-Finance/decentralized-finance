\documentclass[8pt,aspectratio=169]{beamer}
\usetheme{Madrid}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsmath}

\title{L44: Lab -- Security Audit}
\subtitle{Module F: Advanced Topics}
\author{Blockchain \& Cryptocurrency Course}
\date{December 2025}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Lab Overview}
\begin{itemize}
\item \textbf{Objective}: Perform security audit on vulnerable smart contracts
\item \textbf{Skills Practiced}:
\begin{enumerate}
\item Manual code review (identify vulnerabilities by inspection)
\item Automated tool usage (Slither, Mythril)
\item Exploit writing (demonstrate vulnerability)
\item Fix implementation (apply security patterns)
\end{enumerate}
\item \textbf{Contracts to Audit}:
\begin{enumerate}
\item VulnerableBank (reentrancy)
\item InsecureToken (integer overflow, access control)
\item BadOracle (oracle manipulation)
\end{enumerate}
\item \textbf{Deliverable}: Audit report with findings, severity, fixes
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Lab Setup}
\begin{enumerate}
\item \textbf{Install Tools}:
\small
\begin{verbatim}
# Hardhat development environment
npm install --save-dev hardhat
npx hardhat init

# Security tools
pip3 install slither-analyzer
pip3 install mythril
\end{verbatim}
\normalsize
\item \textbf{Clone Vulnerable Contracts Repository}:
\small
\begin{verbatim}
git clone https://github.com/[course-repo]/vulnerable-contracts-lab.git
cd vulnerable-contracts-lab
npm install
\end{verbatim}
\normalsize
\item \textbf{Project Structure}:
\begin{itemize}
\item \texttt{contracts/vulnerable/} -- Contains buggy contracts
\item \texttt{contracts/secure/} -- Empty (your fixes go here)
\item \texttt{test/exploits/} -- Write exploit tests
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Exercise 1: VulnerableBank Contract}
\textbf{Contract Code}:
\small
\begin{verbatim}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VulnerableBank {
    mapping(address => uint) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint _amount) public {
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");
        balances[msg.sender] -= _amount;
    }

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}
\end{verbatim}
\normalsize
\end{frame}

\begin{frame}[fragile]{Exercise 1: Tasks}
\begin{enumerate}
\item \textbf{Manual Review}:
\begin{itemize}
\item Read the contract code carefully
\item Identify the vulnerability (hint: focus on \texttt{withdraw} function)
\item Classify the vulnerability type
\item Assess severity (Critical, High, Medium, Low)
\end{itemize}
\item \textbf{Automated Analysis}:
\small
\begin{verbatim}
slither contracts/vulnerable/VulnerableBank.sol
myth analyze contracts/vulnerable/VulnerableBank.sol
\end{verbatim}
\normalsize
\begin{itemize}
\item Compare tool findings with your manual review
\item Do tools identify the vulnerability?
\end{itemize}
\item \textbf{Write Exploit}: Create \texttt{AttackBank.sol} to drain funds
\item \textbf{Implement Fix}: Create \texttt{SecureBank.sol} with proper mitigations
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Exercise 1: Exploit Contract}
\textbf{Task}: Write \texttt{AttackBank.sol} to exploit reentrancy
\small
\begin{verbatim}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./VulnerableBank.sol";

contract AttackBank {
    VulnerableBank public vulnerableBank;
    uint public attackAmount;

    constructor(address _vulnerableBankAddress) {
        vulnerableBank = VulnerableBank(_vulnerableBankAddress);
    }

    // TODO: Implement attack logic
    // 1. Deposit funds into VulnerableBank
    // 2. Call withdraw to trigger reentrancy
    // 3. Fallback function recursively calls withdraw

    receive() external payable {
        // TODO: Implement reentrancy logic
    }
}
\end{verbatim}
\normalsize
\end{frame}

\begin{frame}[fragile]{Exercise 1: Secure Implementation}
\textbf{Task}: Implement \texttt{SecureBank.sol} with reentrancy protection
\vspace{0.3cm}
\textbf{Mitigation Options}:
\begin{enumerate}
\item \textbf{Checks-Effects-Interactions Pattern}:
\begin{itemize}
\item Update state before external call
\end{itemize}
\item \textbf{Reentrancy Guard}:
\small
\begin{verbatim}
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SecureBank is ReentrancyGuard {
    function withdraw(uint _amount) public nonReentrant {
        // Protected against reentrancy
    }
}
\end{verbatim}
\normalsize
\item \textbf{Verify with Slither}: Ensure no reentrancy warnings
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Exercise 2: InsecureToken Contract}
\textbf{Contract Code}:
\small
\begin{verbatim}
pragma solidity ^0.7.6;  // Vulnerable version

contract InsecureToken {
    mapping(address => uint256) public balances;
    address public owner;

    function mint(address _to, uint256 _amount) public {
        balances[_to] += _amount;  // No overflow check!
    }

    function transfer(address _to, uint256 _amount) public {
        require(balances[msg.sender] >= _amount);
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
    }

    function destroyContract() public {
        selfdestruct(payable(owner));  // No access control!
    }
}
\end{verbatim}
\normalsize
\textbf{Multiple vulnerabilities present}
\end{frame}

\begin{frame}[fragile]{Exercise 2: Tasks}
\begin{enumerate}
\item \textbf{Manual Review}: Identify ALL vulnerabilities
\begin{itemize}
\item Hint: Look for integer overflow, access control, uninitialized variables
\item List each vulnerability with severity
\end{itemize}
\item \textbf{Run Slither and Mythril}:
\small
\begin{verbatim}
slither contracts/vulnerable/InsecureToken.sol --solc-version 0.7.6
\end{verbatim}
\normalsize
\begin{itemize}
\item Which vulnerabilities do tools detect?
\item Any false positives or missed issues?
\end{itemize}
\item \textbf{Exploit Scenarios}:
\begin{itemize}
\item Overflow \texttt{balances} by minting large amounts
\item Call \texttt{destroyContract} as non-owner
\end{itemize}
\item \textbf{Implement SecureToken.sol}:
\begin{itemize}
\item Upgrade to Solidity 0.8.0+ (built-in overflow checks)
\item Add \texttt{onlyOwner} modifier
\item Initialize \texttt{owner} in constructor
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Exercise 2: Secure Implementation}
\textbf{Fix Vulnerabilities}:
\small
\begin{verbatim}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";

contract SecureToken is Ownable {
    mapping(address => uint256) public balances;

    // Overflow protection: Solidity 0.8.0+ built-in
    function mint(address _to, uint256 _amount) public onlyOwner {
        balances[_to] += _amount;  // Safe from overflow
    }

    function transfer(address _to, uint256 _amount) public {
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        balances[msg.sender] -= _amount;  // Safe from underflow
        balances[_to] += _amount;
    }

    // Access control: onlyOwner prevents unauthorized destruction
}
\end{verbatim}
\normalsize
\end{frame}

\begin{frame}[fragile]{Exercise 3: BadOracle Contract}
\textbf{Contract Code}:
\small
\begin{verbatim}
interface IUniswapV2Pair {
    function getReserves() external view returns (uint112, uint112, uint32);
}

contract BadOracle {
    IUniswapV2Pair public pair;

    function getPrice() public view returns (uint) {
        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();
        return (reserve1 * 1e18) / reserve0;  // Instant price, manipulable!
    }

    function borrow(uint collateralAmount) public {
        uint collateralValue = collateralAmount * getPrice();
        // Lend based on manipulable oracle...
    }
}
\end{verbatim}
\normalsize
\textbf{Vulnerability}: Single-block price manipulation via flash loans
\end{frame}

\begin{frame}{Exercise 3: Tasks}
\begin{enumerate}
\item \textbf{Manual Review}:
\begin{itemize}
\item Why is this oracle vulnerable?
\item How can an attacker manipulate \texttt{getPrice()}?
\item Design flash loan attack scenario
\end{itemize}
\item \textbf{Write Exploit}:
\begin{itemize}
\item Use Hardhat mainnet fork
\item Flash loan from Aave
\item Manipulate Uniswap pool
\item Exploit \texttt{BadOracle.borrow()}
\item Restore pool state, repay flash loan
\end{itemize}
\item \textbf{Implement Secure Oracle}:
\begin{itemize}
\item Option 1: Uniswap V2 TWAP oracle
\item Option 2: Chainlink price feed
\item Option 3: Hybrid (multiple sources)
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Exercise 3: Secure Oracle Implementation}
\textbf{Option 1: Uniswap V2 TWAP}:
\small
\begin{verbatim}
import "@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol";

contract SecureOracle {
    address public pair;
    uint public price0CumulativeLast;
    uint32 public blockTimestampLast;
    uint public constant PERIOD = 1 hours;

    function update() external {
        (uint price0Cumulative, , uint32 blockTimestamp) =
            UniswapV2OracleLibrary.currentCumulativePrices(pair);
        uint timeElapsed = blockTimestamp - blockTimestampLast;
        require(timeElapsed >= PERIOD, "Period not elapsed");
        // Calculate TWAP over PERIOD
        uint priceAverage = (price0Cumulative - price0CumulativeLast) / timeElapsed;
        // Update stored values...
    }
}
\end{verbatim}
\normalsize
\textbf{Attacker must manipulate price for 1 hour (expensive)}
\end{frame}

\begin{frame}[fragile]{Exercise 3: Chainlink Integration}
\textbf{Option 2: Chainlink Price Feed}:
\small
\begin{verbatim}
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract ChainlinkOracle {
    AggregatorV3Interface internal priceFeed;

    constructor(address _priceFeed) {
        priceFeed = AggregatorV3Interface(_priceFeed);
    }

    function getPrice() public view returns (int) {
        (
            , // roundId
            int price,
            , // startedAt
            uint timeStamp,
            // answeredInRound
        ) = priceFeed.latestRoundData();
        require(timeStamp > 0, "Round not complete");
        return price;
    }
}
\end{verbatim}
\normalsize
\textbf{Decentralized oracle network, manipulation-resistant}
\end{frame}

\begin{frame}[fragile]{Slither Deep Dive}
\textbf{Run Slither with Detailed Output}:
\small
\begin{verbatim}
slither . --print human-summary
slither . --detect reentrancy-eth,reentrancy-no-eth
slither . --exclude-informational --exclude-low
\end{verbatim}
\normalsize
\vspace{0.3cm}
\textbf{Detector Categories}:
\begin{itemize}
\item \textbf{High/Critical}: Reentrancy, access control, uninitialized storage
\item \textbf{Medium}: Timestamp dependence, weak randomness
\item \textbf{Low}: Solidity version, naming conventions
\item \textbf{Informational}: Gas optimizations, best practices
\end{itemize}
\vspace{0.3cm}
\textbf{Integration}: Add to CI/CD pipeline
\small
\begin{verbatim}
slither . --fail-high --fail-medium
\end{verbatim}
\normalsize
\end{frame}

\begin{frame}[fragile]{Mythril Deep Dive}
\textbf{Run Mythril with Specific Modules}:
\small
\begin{verbatim}
myth analyze contracts/VulnerableBank.sol \
    --execution-timeout 300 \
    --solver-timeout 10000 \
    --max-depth 50
\end{verbatim}
\normalsize
\vspace{0.3cm}
\textbf{Interpretation of Results}:
\begin{itemize}
\item \textbf{SWC-107}: Reentrancy
\item \textbf{SWC-101}: Integer overflow/underflow
\item \textbf{SWC-105}: Unprotected ether withdrawal
\item \textbf{SWC-115}: Authorization through tx.origin
\end{itemize}
\vspace{0.3cm}
\textbf{Limitations}:
\begin{itemize}
\item Path explosion for complex contracts
\item False positives possible
\item Combine with manual review
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Writing Exploit Tests}
\textbf{Hardhat Test Structure}:
\small
\begin{verbatim}
const { expect } = require("chai");

describe("VulnerableBank Exploit", function () {
  it("Should drain bank via reentrancy", async function () {
    const [attacker, victim] = await ethers.getSigners();

    // Deploy VulnerableBank
    const Bank = await ethers.getContractFactory("VulnerableBank");
    const bank = await Bank.deploy();

    // Victim deposits 10 ETH
    await bank.connect(victim).deposit({ value: ethers.utils.parseEther("10") });

    // Deploy AttackBank
    const Attack = await ethers.getContractFactory("AttackBank");
    const attack = await Attack.deploy(bank.address);

    // Execute attack
    await attack.attack({ value: ethers.utils.parseEther("1") });

    // Verify bank is drained
    expect(await ethers.provider.getBalance(bank.address)).to.equal(0);
  });
});
\end{verbatim}
\normalsize
\end{frame}

\begin{frame}{Audit Report Template}
\textbf{Professional Audit Report Structure}:
\begin{enumerate}
\item \textbf{Executive Summary}:
\begin{itemize}
\item Scope, methodology, timeline
\item High-level findings summary
\end{itemize}
\item \textbf{For Each Finding}:
\begin{itemize}
\item Title: ``Reentrancy in withdraw function''
\item Severity: Critical / High / Medium / Low / Informational
\item Location: Contract name, line numbers
\item Description: Explain the vulnerability
\item Impact: What can an attacker achieve?
\item Proof of Concept: Code or steps to reproduce
\item Recommendation: How to fix (with code example)
\end{itemize}
\item \textbf{Summary Table}: All findings with severity
\item \textbf{Conclusion}: Overall security assessment
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Sample Finding: Reentrancy}
\small
\textbf{Finding: Reentrancy Vulnerability in VulnerableBank.withdraw()}

\textbf{Severity}: Critical

\textbf{Location}: \texttt{contracts/VulnerableBank.sol, lines 12-16}

\textbf{Description}: The \texttt{withdraw} function performs an external call to \texttt{msg.sender} before updating the user's balance. This allows a malicious contract to recursively call \texttt{withdraw} and drain funds.

\textbf{Impact}: Complete loss of contract funds. An attacker can drain the entire bank balance in a single transaction.

\textbf{Proof of Concept}: See \texttt{test/exploits/test-reentrancy.js}

\textbf{Recommendation}: Apply Checks-Effects-Interactions pattern:
\begin{verbatim}
balances[msg.sender] -= _amount;  // State update FIRST
(bool success, ) = msg.sender.call{value: _amount}("");  // External call LAST
\end{verbatim}
Alternatively, use OpenZeppelin's ReentrancyGuard.
\normalsize
\end{frame}

\begin{frame}{Lab Deliverable Checklist}
\textbf{Submit the Following}:
\begin{enumerate}
\item \textbf{Audit Report (PDF)}:
\begin{itemize}
\item Findings for all three contracts
\item Severity classifications
\item Recommendations with code
\end{itemize}
\item \textbf{Exploit Contracts}:
\begin{itemize}
\item \texttt{AttackBank.sol}
\item \texttt{ExploitToken.sol}
\item \texttt{OracleAttack.sol}
\end{itemize}
\item \textbf{Secure Implementations}:
\begin{itemize}
\item \texttt{SecureBank.sol}
\item \texttt{SecureToken.sol}
\item \texttt{SecureOracle.sol}
\end{itemize}
\item \textbf{Test Suite}:
\begin{itemize}
\item Tests demonstrating exploits
\item Tests proving secure versions are not exploitable
\end{itemize}
\item \textbf{Tool Output}: Slither and Mythril reports
\end{enumerate}
\end{frame}

\begin{frame}{Bonus Challenge: Advanced Vulnerabilities}
\textbf{Optional Advanced Exercises}:
\begin{enumerate}
\item \textbf{Flashloan + Oracle Attack}:
\begin{itemize}
\item Combine flash loan with BadOracle exploit
\item Maximize profit extraction
\end{itemize}
\item \textbf{Signature Replay Attack}:
\begin{itemize}
\item Contract accepts signed messages for token transfers
\item Exploit lack of nonce/chainId
\end{itemize}
\item \textbf{Delegate Call Vulnerability}:
\begin{itemize}
\item Proxy contract with storage collision
\item Overwrite critical state variables
\end{itemize}
\item \textbf{Gas Griefing DoS}:
\begin{itemize}
\item Unbounded loop in distribution function
\item Make contract unusable by adding many recipients
\end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}{Summary}
\begin{itemize}
\item \textbf{Security audit workflow}: Manual review $\rightarrow$ Automated tools $\rightarrow$ Exploit $\rightarrow$ Fix
\item \textbf{Exercise 1}: Reentrancy in VulnerableBank (Checks-Effects-Interactions fix)
\item \textbf{Exercise 2}: Integer overflow + access control in InsecureToken (Solidity 0.8.0+ fix)
\item \textbf{Exercise 3}: Oracle manipulation in BadOracle (TWAP or Chainlink fix)
\item \textbf{Tools}: Slither (fast static analysis), Mythril (symbolic execution)
\item \textbf{Exploit writing}: Demonstrate real attack scenarios in tests
\item \textbf{Deliverable}: Professional audit report with findings and recommendations
\item \textbf{Real-world skills}: Manual code review remains critical, tools complement but don't replace human analysis
\end{itemize}
\end{frame}

\end{document}
